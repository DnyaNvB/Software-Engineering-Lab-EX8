# Software-Engineering-Lab-EX8
**لینک کانبان برد: https://github.com/users/DnyaNvB/projects/7/views/1
**
# بخش اول - پیاده سازی الگوی Adapter:

## زیربخش اول - انتخاب نوع Adapter :

در پیاده‌سازی ارائه شده، از Object Scope برای پیاده‌سازی الگوی Adapter استفاده شده است. علت انتخاب این روش و عدم استفاده از Class Scope به شرح زیر است:

علت استفاده از Object Scope:

انعطاف‌پذیری بیشتر: در Object Scope، می‌توان چندین نمونه از یک Adapter ایجاد کرد که هر یک با نمونه‌های مختلفی از کلاس‌های دیگر (مانند گراف‌های مختلف) کار کنند. این ویژگی به پروژه امکان می‌دهد وابستگی‌ها را پویا و انعطاف‌پذیر مدیریت کند.

استقلال از ساختار وراثت: در این پروژه از کلاس SparseMultigraph استفاده شده است که ممکن است از پیش سلسله مراتبی از کلاس‌ها را به ارث برده باشد. با استفاده از Object Scope، می‌توانیم بدون درگیر شدن با ساختار وراثت، Adapter را به راحتی پیاده‌سازی کنیم.

ساده‌تر بودن نگهداری و تغییرات: با تغییر کتابخانه یا ساختار داخلی گراف، تنها نیاز به تغییر در کلاس Adapter داریم، بدون نیاز به بازتعریف یا تغییر در سلسله مراتب کلاس‌ها.


علت عدم استفاده از Class Scope:

محدودیت در وراثت جاوا: زبان جاوا به صورت تک‌وراثتی عمل می‌کند. در نتیجه، اگر بخواهیم از Class Scope استفاده کنیم، مجبور به وراثت از کلاس SparseMultigraph می‌شویم، که ممکن است محدودیت‌هایی ایجاد کند و امکان ترکیب با سایر کلاس‌ها را کاهش دهد.

کاهش قابلیت استفاده مجدد: Class Scope بیشتر وابسته به ساختار سلسله مراتبی است و قابلیت استفاده مجدد از Adapter در موقعیت‌های مختلف را کاهش می‌دهد.

افزایش پیچیدگی: استفاده از Class Scope ممکن است تغییرات بیشتری در ساختار پروژه ایجاد کند که نگهداری کد را پیچیده‌تر می‌کند.
در نتیجه، با توجه به انعطاف‌پذیری و استقلال بیشتری که Object Scope فراهم می‌کند، این روش برای پروژه انتخاب شده است.

## زیربخش دوم - نحوه پیاده سازی الگو:

برای پیاده‌سازی الگوی آداپتور با استفاده از مدل Object Scope، ابتدا رابطی به نام GraphAdapter تعریف کردیم که عملیات‌های اساسی مورد نیاز برای مدیریت گراف (مانند افزودن رأس‌ها، افزودن یال‌ها و بازیابی همسایگان) را مشخص می‌کرد. این رابط به‌عنوان قراردادی عمل می‌کند که تمامی کلاس‌های آداپتور باید آن را پیاده‌سازی کنند.

سپس کلاسی به نام Adapter پیاده‌سازی کردیم که رابط GraphAdapter را اجرا می‌کرد. در این کلاس، نمونه‌ای از SparseMultigraph مربوط به کتابخانه JUNG را به‌عنوان عضو داخلی نگهداری کردیم و تمامی فراخوانی‌های متدها (مانند افزودن رأس‌ها و یال‌ها) را به متدهای معادل در SparseMultigraph ارسال کردیم. با این کار، برنامه را از وابستگی مستقیم به SparseMultigraph جدا کردیم و امکان تعامل از طریق آداپتور را فراهم ساختیم.

در ادامه، کلاس‌های BfsGraphTraverser و DfsGraphTraverser را تغییر دادیم تا به‌جای وابستگی مستقیم به SparseMultigraph، از رابط GraphAdapter استفاده کنند. این تغییر باعث شد که این کلاس‌ها نسبت به کتابخانه خاص مستقل شوند و بتوانیم تنها با تغییر آداپتور، کتابخانه گراف مورد استفاده را تغییر دهیم.

در نهایت، کلاس Main را نیز به‌روزرسانی کردیم تا از Adapter به‌عنوان پیاده‌سازی رابط GraphAdapter استفاده کند. این تغییر باعث شد که برنامه به‌جای وابستگی مستقیم به کتابخانه JUNG، تنها از طریق آداپتور با گراف تعامل داشته باشد.

استفاده از مدل Object Scope به ما این امکان را داد که چندین نمونه از آداپتور ایجاد کنیم، به‌طوری که هرکدام بتوانند گراف‌های مستقل خود را مدیریت کنند.

# بخش دوم - تغییر کتابخانه:


## زیربخش اول:

کتابخانه‌ای که برای عملیات‌های گراف در پروژه استفاده می‌شد، از JUNG به JGraphT تغییر داده شد. این تغییر به‌صورت یکپارچه و با استفاده از الگوی طراحی آداپتور انجام شد که منطق پروژه را از وابستگی به کتابخانه خاص جدا کرده بود.

برای این تغییر، همان آداپتور قبلی را تغییر دادیم و به‌گونه‌ای پیاده‌سازی کردیم که با کتابخانه JGraphT سازگار باشد. در این نسخه جدید، از کلاس‌های کتابخانه JGraphT، به‌ویژه DefaultUndirectedGraph، برای نمایش داخلی گراف استفاده شد. متدهای تعریف‌شده در آداپتور (مانند افزودن رأس، افزودن یال و بازیابی همسایگان) به متدهای متناظر در JGraphT متصل شدند تا همان عملکرد کتابخانه قبلی حفظ شود.

بقیه کدهای پروژه، Main، کلاس‌های traverser مانند BfsGraphTraverser و DfsGraphTraverser، بدون هیچ تغییری باقی ماندند. زیرا این کلاس‌ها تنها با آداپتور تعامل داشتند و به جزئیات پیاده‌سازی کتابخانه خاص وابسته نبودند. (اسم Adapter هم ثابت باقی مانده بود)

این تغییر نشان داد که استفاده از الگوی آداپتور چگونه می‌تواند تغییر کتابخانه‌ها را با حداقل تاثیر بر کدهای اصلی پروژه امکان‌پذیر سازد. تنها تغییرات مورد نیاز، تغییر آداپتور قبلی بود، و باقی منطق پروژه بدون هیچ تغییری به کار خود ادامه داد. این انعطاف‌پذیری به لطف جدا کردن وابستگی‌ها از منطق اصلی برنامه فراهم شد.

## زیربخش دوم:
تغییر کتابخانه از JUNG به JGraphT عمدتا شامل تغییر آداپتور موجود و به‌روزرسانی وابستگی‌های پروژه بود. در این فرآیند، ساختار اصلی پروژه بدون تغییر باقی ماند و تنها بخشی که به کتابخانه وابسته بود، اصلاح شد.

تنها تغییر، به‌روزرسانی آداپتور بود. در این مرحله، نمایش داخلی گراف در آداپتور از SparseMultigraph (متعلق به JUNG) به DefaultUndirectedGraph (متعلق به JGraphT) تغییر یافت. همچنین متدهای آداپتور، مانند addVertex، addEdge و getNeighbors، برای استفاده از API کتابخانه JGraphT بازنویسی شدند. به‌عنوان مثال، در کتابخانه JUNG یال‌ها با استفاده از یک شناسه‌ی متنی مشخص می‌شدند، اما JGraphT نیازی به چنین شناسه‌هایی ندارد. این تفاوت در منطق آداپتور اعمال شد تا عملکرد کتابخانه جدید به درستی با نیازهای پروژه همخوانی داشته باشد.

برای وابستگی‌های پروژه نیز فایل pom.xml هر دو کتابخانه را داشتند و نیازی به تغییر ما نبود.

ساختار اصلی پروژه، شامل کلاس‌های traverser مانند BfsGraphTraverser و DfsGraphTraverser، هیچ تغییری نکرد. این کلاس‌ها همچنان با آداپتور تعامل دارند و از جزئیات پیاده‌سازی کتابخانه جدید بی‌نیاز هستند. در نتیجه، منطق اصلی برنامه کاملا بدون تغییر باقی ماند و چون اسم آداپتور هم Adapter بود و تغییری نیافت، تغییری در کلاس Main نیاز نبود.

تغییر کتابخانه هیچ تغییری در عملکرد برنامه ایجاد نکرد و نتایج پیمایش گراف (BFS و DFS) همانند قبل باقی ماند. این امر نشان‌دهنده این است که استفاده از الگوی آداپتور چگونه توانسته وابستگی به کتابخانه خاص را جدا کرده و امکان تغییر کتابخانه‌ها را بدون تأثیر بر منطق اصلی برنامه فراهم کند. این تغییرات، اگرچه در سطح کتابخانه‌ای قابل توجه بودند، به دلیل طراحی مناسب و استفاده از الگوی آداپتور، به حداقل کاهش یافته و مدیریت پروژه را ساده‌تر کردند.



# بخش سوم - تحلیل الگوی استراتژی:

1. علت قابل قبول بودن استفاده از الگوی Strategy

استفاده از الگوی Strategy در این پروژه قابل قبول است زیرا این الگو به ما اجازه می‌دهد تا الگوریتم‌های مختلف پیمایش گراف (مانند BFS و DFS) را به صورت جداگانه و مستقل از یکدیگر پیاده‌سازی کنیم. این مزیت‌ها شامل موارد زیر است:

جداسازی منطق الگوریتم‌ها: هر الگوریتم پیمایش (BFS و DFS) در کلاس‌های جداگانه پیاده‌سازی شده و تغییر یا گسترش هر یک از این الگوریتم‌ها بدون تأثیر بر دیگر بخش‌های کد ممکن است.

انعطاف‌پذیری بالا: می‌توان الگوریتم‌های جدید را به سادگی اضافه کرد یا الگوریتم‌های موجود را تغییر داد، بدون نیاز به تغییر کدهای موجود.

قابلیت جایگزینی: در اینجا می‌توان به راحتی بین الگوریتم‌های مختلف پیمایش گراف با تغییر کلاس Traverser استفاده‌شده در Main جابجا شد.

کاهش پیچیدگی: با جداسازی منطق پیمایش، کلاس اصلی Main ساده‌تر و خواناتر شده است.



۲. روش تحقق الگوی Strategy در این پروژه

الگوی Strategy در این پروژه به صورت زیر پیاده‌سازی شده است:

تعریف اینترفیس (Interface):

یک اینترفیس به نام Traverser تعریف شده که متدی با امضای traverse(Integer startVertex) را مشخص می‌کند. این اینترفیس نقش استراتژی اصلی را دارد و الگوریتم‌های مختلف باید آن را پیاده‌سازی کنند.

public interface Traverser {

    List<Integer> traverse(Integer startVertex);
    
}



پیاده‌سازی استراتژی‌های مختلف:

دو کلاس BfsGraphTraverser و DfsGraphTraverser از اینترفیس Traverser استفاده کرده و الگوریتم‌های BFS و DFS را به صورت مستقل پیاده‌سازی کرده‌اند.

کلاس BfsGraphTraverser الگوریتم جستجوی سطحی (BFS) را با استفاده از صف (Queue) پیاده‌سازی کرده است.

کلاس DfsGraphTraverser الگوریتم جستجوی عمقی (DFS) را با استفاده از پشته (Stack) پیاده‌سازی کرده است.

استفاده از الگوی Strategy در Main:

در کلاس Main، گراف ساخته شده و سپس یک نمونه از هر دو کلاس BfsGraphTraverser و DfsGraphTraverser ایجاد شده است.
کد به گونه‌ای طراحی شده که می‌توان با تغییر نوع استراتژی (کلاس Traverser) الگوریتم پیمایش گراف را تغییر داد:


Traverser dfsGraphTraveler = new DfsGraphTraverser(graph);

Traverser bfsGraphTraveler = new BfsGraphTraverser(graph);

List<Integer> dfsPath = dfsGraphTraveler.traverse(1);

List<Integer> bfsTraveler = bfsGraphTraveler.traverse(1);




